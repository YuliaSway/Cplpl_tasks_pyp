// чтобы пользоваться ядром языка, то ничего подключать не надо
// если использовать возмодности STD, то нужно через include подключать заголовочные файлы :

#include <iostream>
#include <string> // можно через ctrl открыть

// базовые типы данных
// код программы -> компилятор под нужную архитектуру -> исполняемый файл

// встроенные типы данных:
// bool , char , int , long , float , double , ...

// двоичная система счисления, почему выбрана
    // каждая переменная должна иметь свой тип, - статическая типизация
    // в С++ нет динамической типизации. 
    // за все время жизни переменной нельзя изменить её тип
	// все переменные должны иметь тип известный на момент компиляции


// 
namespace my_own_namespace {
	int global_variable = 42;
	std::string global_str = "String";
	
	int var1;
    int var2;
    
    void test(){
        var1 = 21;
        var2 = 3;

        int result = var1 + var2;
    }
}

//если используется две разные переменные с одинаковым именем, то нельзя объявлять так:
// std::string name = "Vasia";
// std::string name = "Ivan";
// нужно разделить с помощью namespace:

namespace module1
{
	std::string name = "Vasia";
} 
namespace module2{
	std::string name = "Ivan";
}

// в C++ есть две части: 1. core языка (Core) , 2. стандартная библиотека (Standart Library)
// обе части входят в стандарт языка
// есть ещё две части: 3. C , 4. C Library
// std::string реализация:
// namespace std {
//  	struct string {...};  // реализация динамических строк , расположена в стандартной библиотеки
// }   
// eNUM ???
// в чем отличие string от std::string ???


int main() {

	module1::name; // Vasia, обращение к переменной через пространство имен
	module2::name; // Ivan


	// std::cout
	// стандартный вывод, т.к. при запуске операционная система определяет и дает права устройству ввода/вывода (клавиатура,мышь / консоль)
	// standart output
	// т.е. в какой то системе может быть устройство вывода - светодиод, в других специальный экран и т.д. Т.е. определено на уровне ОС

	// << - направление движения данных

	// std::endl
	// endline - перевод строки
	std::cout << "global_variable = " << my_own_namespace::global_variable << std::endl;

	{
		using namespace my_own_namespace;
		// - после этой строки можно ко всех переменным этого ns обращаться по имени без указания префикса этого ns
		// по факту "отменяем" ns,  и можем попасть в конфликт
		// поэтому нужно использовать только в нужных местах, в локальных местах
		// работает до завершения скоупа (scope, область видимости, область жизни), т.е. } отменяет его действие
		std::cout << "global_variable (after using) = " << global_variable << std::endl;
		// можно искусственно задать scope
	}


	// в C++ одно плохое правило, что локальные переменные "скрывают" глобальные переменные (shadowing)
	// например, в ns есть переменная global_variable, используем ns, обращаясь к её переменной по имени
	// далее объявляем ещё переменную с таким же именем, синтаксически ошибки нет
	// т.к. локальные переменные имеют бJльший приоритет, нежели глобальные
	// это правило зафиксировано на низком уровне языка
	{
		using namespace my_own_namespace;
		int global_variable = 56;   // в ядре языка тип данных, не в std
	
		std::cout << "global_variable (after local) = " << global_variable << std::endl; // обращаемся к локальн.переменной, не глобальной
		// к переменной ns обращаемся через префикс, несмотря на using  ns :
		std::cout << "my_own_namespace::global_variable (after local) = " << my_own_namespace::global_variable << std::endl;

	}

	// несколько сразу переменных объявить, без инициализации:
	int value1, value2;
	std::string name;  // в стандартной библиотеке

	// standart output
	std::cout << "Input your name: " << std::endl;
	// стандартный ввод , standart input
	std::cin >> name; // считываем и записываем в переменную name
	// проверок не выполняется, всегда предполагается, что это строка и не важно какие данные вводим если name - string

	std::cout << "Input your name (without endl): ";
	std::cin >> name;

	std::cout << "Input value1 and value2: " << std::endl;
	// если в качестве значений переменных указать не число, то переменные не будут проинициализированны и останутся пустыми
	// если введем например "455прловрпло", то стандартная бибилиотека прочитает численную часть 455, а остальные символы проигнорирует
	// но есть какие-то обработчики .... ???
	std::cin >> value1 >> value2;

	std::cout << "Hi (without endl), " << name << std::endl;
	std::cout << "Hi, " << name << std::endl;
	std::cout << "sum of two values is: " << value1 + value2 << std::endl;

	return 0;
}


